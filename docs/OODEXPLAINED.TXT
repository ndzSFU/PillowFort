The two interesting actions that our game must support that we will talk about is how we produce and place forts on the board, and how we print the board normally and with the --cheat argument. In our design, we have a GameBoard class that stores the game board, a fort class to handle the points that each fort produces, and a GameSpot class which stores the data for an individual spot on the game board. The game board is an ArrayList of ArrayLists (an arraylist that stores each row, where each row is its own arraylist) which consists of not 100 but 144 GameSpots (12 for each of the 12 rows). This allows the board to have a single, 1 GameSpot thick outline which helps us determine whether or not we are on the board. These GameSpots are marked as “invalid” meaning that they are not actually on the playable board. We also made two ArrayLists, one for possible fort spots, and one for the forts spots that are currently in the fort we are creating. For the fort placement, we decided to randomly select a valid (on the board) GameSpot that is also not already a fort (we have a boolean in GameSpot for this). When we pick one that satisfies these conditions, we mark it as a possibleFort and place it into an ArrayList of other possible fort spots. Then, from the currently selected spot, we look at all the GameSpots directly touching the current spot in the cardinal directions and determine if they are also possible forts (i.e. the satisfy the previously described conditions). If a spot satisfies the conditions, we add it to the ArrayList of possible fort spots.
Then we remove the spot that we are currently on, add it to the ArrayList of spots that is for the current fort, and then remove it from the possibleFort ArrayList. This is for the first spot that goes into the fort. Afterwards, the only thing that changes is the spot we are looking at, which we determine by randomly selecting one of the possible forts from the possibleFort ArrayList. Then we follow the same steps until the ArrayList that has the actual fort is size 5. If we cannot make a fort of size 5, we recall the function again until we produce a fort. If we do this 100 times and we still cannot make a fort of size 5, we conclude that there is no possible way to make another fort, and the program crashes. Our OOD greatly supports the use of the GameSpot class, because the entire board is made of GameSpots. Since each spot is its own object, we can easily determine the individual status of each GameSpot to help us determine if GameSpots are on the board, possibleForts, or if it is part of an actual fort and which fort it is a part of. In our design, the GameBoard class generates the forts. In this generation, the GameSpot class is heavily utilized to decide which spots may be a fort, and which are added to a fort etc.

Our system implemented the UI classes' primary public methods to require an already instatiated GameBoard as input. The display/output functions like dislay board all used information stored within the board to properly print outputs. Inside of Print Board, there was also 3 functions which took GameSpots as input, and printed the spot differently depending on if the game was done, and if there was cheat enabled. This allowed the GameRunner to call the same print board function, no matter teh circumstance, and just take in what type of printing it should be doing.